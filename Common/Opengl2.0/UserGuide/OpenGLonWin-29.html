<!-- Generated by Harlequin Webmaker 2.1.3; Transducer 1.0.2 --> <HTML> <HEAD>
<TITLE>Tuning the Raster Subsystem</TITLE>
</HEAD>
<BODY Y BGCOLOR="efefef" LINK="0000FF" ALINK="FF0000" VLINK="551a8b">
<A NAME=HEADING29></A>
<A HREF=OpenGLonWin-30.html>Next</A> | <A HREF=OpenGLonWin-28.html>Prev</A> | <A HREF=OpenGLonWin-26.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
<HR>
<A NAME=HEADING29-0></A>
<H2> <A NAME=MARKER-9-53></A>Tuning the Raster Subsystem<A NAME=MARKER-2-54></A></H2>
<P>An explosion of both data and operations is required to rasterize a polygon as individual pixels. Typically, the operations include depth comparison, Gouraud shading, color blending, logical operations, texture mapping, and possibly antialiasing. The following techniques can improve performance for a fill-limited application: <P>
<UL>
<P><LI><A HREF=#MARKER-9-55>"Using Backface or Frontface Removal"</A>
<P><LI><A HREF=#MARKER-9-62>"Other Considerations for Raster Subsystem Tuning"</A>
<P><LI><A HREF=OpenGLonWin-28.html#MARKER-9-33>"Using Expensive Modes Efficiently"</A>
<P><LI><A HREF=#MARKER-9-65>"Balancing Polygon Size and Pixel Operations"</A>
<P><LI><A HREF=#MARKER-9-66>"Clearing the Color and Depth Buffers Simultaneously"</A>
</UL>
<A NAME=HEADING29-7></A>
<H3> <A NAME=MARKER-9-55></A>Using Backface or Frontface Removal</H3>
<P>To reduce fill-limited drawing, use backface or frontface removal.<A NAME=MARKER-2-56></A> For example, if you are drawing a sphere, half of its polygons are backfacing at any given time. Backface and <A NAME=MARKER-2-57></A>frontface removal is done after transformation calculations but before per-fragment operations. This means that <A NAME=MARKER-2-58></A>backface removal may make transform-limited polygons somewhat slower, but make fill-limited polygons significantly faster. You can turn on backface removal when you are drawing an object with many backfacing polygons, then turn it off again when drawing is completed.<P>
<A NAME=HEADING29-9></A>
<H4> Using Depth Buffering Efficiently</H4>
<P>Any rendering operation can become fill-limited for large <A NAME=MARKER-2-59></A>polygons. Clever structuring of drawing can eliminate the need for certain fill operations. For example, if large backgrounds are drawn first, they do not need to be depth buffered. It is better to disable <A NAME=MARKER-2-60></A>depth buffering for the backgrounds and then enable it for other objects where it is needed.<P>
<P><A NAME=MARKER-2-61></A>Games and flight simulators often use this technique. The sky and ground are drawn with depth buffering disabled, then the polygons lying flat on the ground (runway and grid) are drawn without a performance penalty. Finally, depth buffering is enabled for drawing the mountains and airplanes.<P>
<P>There are many other special cases in which depth buffering might not be required. For example, terrain, ocean waves, and 3D function plots are often represented as height fields (X-Y grids with one height value at each lattice point). It's straightforward to draw height fields in back-to-front order by determining which edge of the field is furthest away from the viewer, then drawing strips of triangles or quadrilaterals parallel to that starting edge and working forward. The entire height field can be drawn without depth testing, provided it doesn't intersect any piece of previously-drawn geometry. Depth values need not be written at all, unless subsequently-drawn depth buffered geometry might intersect the height field; in that case, depth values for the height field should be written, but the depth test can be avoided by calling<P>
<PRE>
glDepthFunc(GL_ALWAYS)
</PRE>
<A NAME=HEADING29-14></A>
<H3> <A NAME=MARKER-9-62></A>Other Considerations for Raster Subsystem Tuning</H3>
<UL>
<P><LI>Use alpha blending with discretion. 
<P>Alpha blending is an expensive operation. A common use of alpha blending is for <A NAME=MARKER-2-63></A>transparency, where the alpha value denotes the opacity of the object. For fully opaque objects, disable alpha blending.<P>
<P><LI>Avoid unnecessary per-fragment operations. 
<P>Turn off per-fragment operations for objects that do not require them, and structure the drawing process to minimize their use without causing excessive toggling of modes.<P>
<P><LI>Use efficient pixel formats.
<P><LI>Use efficient texture settings.
<P>For example, setting the GL_PERSPECTIVE_CORRECTION_HINT to GL_FASTEST and the texture environment to GL_REPLACE often improves performance significantly. Also, avoid expensive filtering modes such as bilinear and trilinear filtering, if possible.<P>
<P><LI>Organize drawing to minimize <A NAME=MARKER-2-64></A>fill operations. 
<P>For example, if a scene has large background polygons, draw them first without depth buffering, then render the more complex depth-buffered objects.<P>
<P><LI>When defining a texture, use texture objects (see <A HREF=OpenGLonWin-13.html#MARKER-9-15>"Improving Performance With Texture Objects"</A>). This reduces texture state validation during rendering. 
</UL>
<A NAME=HEADING29-25></A>
<H3> <A NAME=MARKER-9-65></A>Balancing Polygon Size and Pixel Operations</H3>
<P>The optimum size of polygons depends on the other operations going on in the pipeline:<P>
<UL>
<P><LI>If the polygons are too large for the fill-rate to keep up with the rest of the pipeline, the application is fill-rate limited. Smaller polygons balance the pipeline and increase the polygon rate.
<P><LI>If the polygons are too small for the rest of the pipeline to keep up with filling, then the application is transform limited. Larger and fewer polygons, or fewer vertices, balance the pipeline and increase the fill rate. 
</UL>
<P>Use the simplest possible fill algorithms for drawing very large polygons, such as backgrounds. <P>
<A NAME=HEADING29-30></A>
<H3> <A NAME=MARKER-9-66></A>Clearing the Color and Depth Buffers Simultaneously</H3>
<P>The most basic per-frame operations are <A NAME=MARKER-2-67></A>clearing the color and depth buffers. On some systems, there are optimizations for common special cases of these operations.<P>
<P>Whenever you need to clear both the color and depth buffers, don't clear each buffer independently. Instead use<P>
<PRE>
glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)<A NAME=MARKER-2-68></A>
</PRE>
<P>Disable dithering before clearing. <P>
<HR>
<DL>
<DT><A HREF="OpenGLonWin-29.html#HEADING29-7"><B></B>Using Backface or Frontface Removal</A><DD>
<DT><A HREF="OpenGLonWin-29.html#HEADING29-9"><B></B>Using Depth Buffering Efficiently</A><DD>
<DT><A HREF="OpenGLonWin-29.html#HEADING29-14"><B></B>Other Considerations for Raster Subsystem Tuning</A><DD>
<DT><A HREF="OpenGLonWin-29.html#HEADING29-25"><B></B>Balancing Polygon Size and Pixel Operations</A><DD>
<DT><A HREF="OpenGLonWin-29.html#HEADING29-30"><B></B>Clearing the Color and Depth Buffers Simultaneously</A><DD>
</DL>

<HR>
<A HREF=OpenGLonWin-30.html>Next</A> | <A HREF=OpenGLonWin-28.html>Prev</A> | <A HREF=OpenGLonWin-26.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
</BODY>
</HTML> 