<!-- Generated by Harlequin Webmaker 2.1.3; Transducer 1.0.2 --> <HTML> <HEAD>
<TITLE>OpenGL 1.1 Vertex Arrays</TITLE>
</HEAD>
<BODY Y BGCOLOR="efefef" LINK="0000FF" ALINK="FF0000" VLINK="551a8b">
<A NAME=HEADING15></A>
<A HREF=OpenGLonWin-16.html>Next</A> | <A HREF=OpenGLonWin-14.html>Prev</A> | <A HREF=OpenGLonWin-12.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
<HR>
<A NAME=HEADING15-0></A>
<H2> <A NAME=MARKER-9-48></A>OpenGL 1.1 Vertex Arrays</H2>
<P><A NAME=MARKER-2-49></A>OpenGL 1.0 provides commands to set vertex coordinates, set the current color, color index, normal vector coordinate, and texture coordinates. The commands accept data in almost any format, but you have to execute the command many times to specify even simple geometry. <P>
<P>In OpenGL 1.1, you may place vertex data into arrays and then use blocks of data in these arrays to specify multiple geometric primitives through the execution of a single command. You may specify up to six arrays; one each to store edge flags, texture coordinates, colors, color indices, normals, and vertices. <P>
<P>The sections listed below discuss several aspects of vertex arrays that help you write more efficient OpenGL programs: <P>
<UL>
<P><LI><A HREF=#MARKER-9-50>"Specifying Vertex Arrays"</A>
<P><LI><A HREF=#MARKER-9-58>"Transferring Individual Array Elements"</A>
<P><LI><A HREF=#MARKER-9-59>"Combining Array Elements From Different Arrays"</A>
<P><LI><A HREF=#MARKER-9-60>"Rendering Primitives Constructed From a Mesh of Vertices"</A>
<P><LI><A HREF=#MARKER-9-61>"Using Interleaved Arrays"</A>
<P><LI><A HREF=#MARKER-9-62>"OpenGL 1.1 and the Vertex Array Extension"</A>
<P><LI><A HREF=#MARKER-9-63>"New Functions"</A>
</UL>
<A NAME=HEADING15-11></A>
<H3> <A NAME=MARKER-9-50></A>Specifying Vertex Arrays</H3>
<P>Six commands (listed below) are available to specify the arrays. A full description for normals, colors, color indexes, texture coordinates, and edge flags is not included here; see the reference pages for more information.<P>
<UL>
<P><LI><B><A NAME=MARKER-2-51></A>glVertexPointer </B>(int <I>size</I>, enum <I>type</I>, sizei <I>stride</I>, void <I>*pointer</I>) <BR>specifies the location and data format of an array of vertex coordinates. 
<UL>
<P><LI><I>size</I> specifies the number of coordinates per vertex, and must be 2, 3, or 4. 
<P><LI><I>type</I> specifies the data type of each coordinate in the array, and must be one of GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE, implying OpenGL data types short, int, float, and double, respectively. 
<P><LI><I>stride</I> specifies the byte offset between pointers to consecutive vertexes. If <I>stride</I> is zero, the vertex data are tightly packed in the array. 
<P><LI><I>pointer</I> specifies a pointer to the first coordinate of the first vertex in the array. 
</UL>
<P><LI><B><A NAME=MARKER-2-52></A><A NAME=MARKER-2-53></A>glNormalPointer()</B> specifies the location and data format of an array of normals. 
<P><LI><B><A NAME=MARKER-2-54></A>glColorPointer()</B> specifies the location and data format of an array of color components.
<P><LI><B><A NAME=MARKER-2-55></A>glIndexPointer()</B> specifies the location and data format of an array of color indexes. 
<P><LI><B><A NAME=MARKER-2-56></A>glTexCoordPointer()</B> specifies the location and data format of an array of texture coordinates. 
<P><LI><B><A NAME=MARKER-2-57></A>glEdgeFlagPointer()</B> specifies the location and data format of an array of Boolean edge flags. 
</UL>
<P>Table 2.4 indicates the allowable values for <I>size</I> and <I>type</I> (when present). <P>
<P>For <I>type</I> the values the following match between OpenGL and C type exist. 
<P><TABLE BORDER="1">
<CAPTION> OpenGL and C Types</CAPTION>
<TH>OpenGL Type<TH>C Type<TR>
<TD>GL_BYTE<TD>byte<TR>
<TD>GL_SHORT<TD>short<TR>
<TD> GL_INT<TD>int <TR>
<TD>GL_FLOAT<TD>float <TR>
<TD>GL_UNSIGNED_BYTE<TD>ubyte<TR>
<TD>GL_UNSIGNED_SHORT<TD>ushort<TR>
<TD>GL_UNSIGNED_INT<TD>uint</TABLE>
<P>
<P>The error GL_INVALID_VALUE is generated if <I>size</I> is specified with a value not included in the table.
<P><TABLE BORDER="1">
<CAPTION> Vertex Array Sizes (Values Per Vertex) and Data Types</CAPTION>
<TH>Command<TH>Sizes<TH>Types<TR>
<TD>glVertexPointer <TD>2,3,4<TD>short, int, float, double<TR>
<TD>glNormalPointer <TD>3<TD>byte, short, int, float, double<TR>
<TD>glColorPointer <TD>3,4<TD>byte, ubyte, short, ushort, int, uint, float, double<TR>
<TD>glIndexPointer<TD>1<TD>ubyte, short, int, float, double<TR>
<TD>glTexCoordPointer<TD>1,2,3,4<TD>short, int, float, double<TR>
<TD>glEdgeFlagPointer <TD>1<TD>boolean</TABLE>
<P>
<P>The one, two, three, or four values in an array that correspond to a single vertex comprise an array element. The values within each array element are stored sequentially in memory.<P>
<P>If <I>stride</I> is zero, then array elements are stored sequentially. Otherwise pointers to element <I>i</I> and (<I>i</I> + 1) of an array differ by <I>stride</I> basic machine units (typically unsigned bytes). <P>
<P>For each command, <I>pointer</I> specifies the location in memory of the first value of the first element of the array being specified.<P>
<A NAME=HEADING15-29></A>
<H3> Enabling and Disabling Individual Arrays</H3>
<P>To enable or disable an individual array, call one of the following functions:<P>
<PRE>
void EnableClientState ( enum array ) ; 
void DisableClientState ( enum array ) ;
</PRE>
<P><I>array</I> should be set to the appropriate value shown in <A HREF=#MARKER-9-4>Table 2-5</A>.
<P><TABLE BORDER="1">
<CAPTION><A NAME=MARKER-9-4></A>  Tokens for Enabling Arrays</CAPTION>
<TH>Array Specification Command<TH>Enable Token<TR>
<TD>glVertexPointer <TD>GL_VERTEX_ARRAY<TR>
<TD>glNormalPointer <TD>GL_NORMAL_ARRAY<TR>
<TD>glColorPointer <TD>GL_COLOR_ARRAY<TR>
<TD>glIndexPointer<TD>GL_INDEX_ARRAY<TR>
<TD>glTexCoordPointer<TD>GL_TEXTURE_COORD_ARRAY<TR>
<TD>glEdgeFlagPointer <TD>GL_EDGE_FLAG_ARRAY</TABLE>
<P>
<A NAME=HEADING15-34></A>
<H3> <A NAME=MARKER-9-58></A>Transferring Individual Array Elements</H3>
<P>To transfer the <I>i</I>th element of an enabled array to OpenGL, call<P>
<PRE>
void glArrayElement ( int <I>i </I>) ;
</PRE>
<P>For each enabled array, it is as though the corresponding creation command (<B>glVertex()</B>, <B>glColor()</B>, and so on) were called with a pointer to element i. For the vertex array, the corresponding command is glVertex[size][type]v, where size is one of [2,3,4], and type is one of [s,i,f,d], corresponding to array types short, int, float, and double respectively. The corresponding commands for the edge flag, texture coordinate, color, color index, and normal arrays are glEdgeFlagv, glTexCoord[size][type]v, glColor[size][type]v, glIndex[type]v, and glNormal[type]v, respectively. If the vertex array is enabled, it is as though glVertex[size][type]v is executed last, after the executions of the other corresponding commands.<P>
<P>Changes made to array data between the execution of <B>glBegin()</B> and the corresponding execution of <B>glEnd()</B> may affect calls to <B>glArrayElement()</B> that are made within the same <B>glBegin()</B> / <B>glEnd()</B> period in non-sequential ways. That is, a call to <B>glArrayElement()</B> that precedes a change to array data may access the changed data, and a call that follows a change to array data may access original data.<P>
<A NAME=HEADING15-39></A>
<H3> <A NAME=MARKER-9-59></A>Combining Array Elements From Different Arrays</H3>
<P>To construct a sequence of geometric primitives using elements <I>first</I> through <I>count </I>of each enabled array, call<P>
<PRE>
void glDrawArrays ( enum mode, int first, sizei count ) ;
</PRE>
<P><I>mode</I> specifies what kind of primitives are constructed; it accepts the same token values as the <I>mode</I> parameter of the <B>glBegin()</B> command. <P>
<P>When you call gl<B>DrawArrays()</B>, OpenGL, in effect, iterates through the elements in the array, starting at <I>first</I> and ending at <I>count</I>, and calls <B>glArrayElement()</B> for each element. <P>
<P>Note that the current edge flag, texture coordinates, color, color index, and normal coordinates are each indeterminate after the execution of <B>glDrawArrays()</B> if the corresponding array is enabled. Current values corresponding to disabled arrays are not modified by the execution of <B>glDrawArrays()</B>.<P>
<A NAME=HEADING15-45></A>
<H3> <A NAME=MARKER-9-60></A>Rendering Primitives Constructed From a Mesh of Vertices</H3>
<P>If you've set up arrays of vertices using one of the commands listed in <A HREF=#MARKER-9-4>Table 2-5</A>, you can then render the primitives constructed from them using <B>glDrawElements(). </B>To construct a sequence of vertices using the <I>count</I> elements whose indices are stored in <I>*indices</I>, call <B>glDrawElements()</B>:<P>
<PRE>
void DrawElements ( enum mode, sizei count, enum type, void *indices );
</PRE>
<P><I>type</I> must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT, indicating that the values in <I>*indices</I> are indices of GL type ubyte, ushort, or uint respectively. <I>mode</I> specifies what kind of primitives are constructed; it accepts the same token values as the <I>mode</I> parameter of the<B> glBegin()</B> command. <P>
<P>When you call <B>glDrawElements()</B>, OpenGL in effect iterates through the elements in the array specified in <I>indices</I> and calls <B>glArrayElement()</B> for each until it has reached <I>count</I> elements. <P>
<P>Note that the current edge flag, texture coordinates, color, color index, and normal coordinates are each indeterminate after the execution of <B>glDrawElements()</B>, if the corresponding array is enabled. Current values corresponding to disabled arrays are not modified by the execution of <B>glDrawElements()</B>.<P>
<A NAME=HEADING15-51></A>
<H3> <A NAME=MARKER-9-61></A>Using Interleaved Arrays</H3>
<P>To further speed up a program that uses vertex arrays, you can call <B>glInterleavedArrays()</B>. The function is faster because you can specify geometry to OpenGL with a single call; you don't need to make a separate call for each type of vertex data. In addition, explicit packing (interleaving) of vertex array data is possible. (In contrast, calls to the individual functions may or may not specify packed array data.) OpenGL implementations may be able to process packed vertex data more quickly. <P>
<P><B>glInterleavedArrays()</B> has the following prototype:<P>
<PRE>
void glInterleavedArrays ( enum <I>format</I>, sizei <I>stride</I>, void <I>*pointer</I> )
</PRE>
<P>If <I>stride</I> is zero, then the aggregate elements are stored consecutively; otherwise, <I>stride</I> bytes occur between aggregate array elements. <P>
<P><I>format</I> serves as a "key" describing the extraction of individual arrays from the aggregate array. The following configurations are possible:<P>
<P> 
<P><TABLE BORDER="1"><TD>V2F<TD>V3F<TD>C4UB_V2F<TD>C4UB_V3F<TD>C3F_V3F<TR>
<TD>N3F_V3F<TD>C4F_N3F_V3F <TD>T2F_V3F<TD> T4F_V4F<TD>T2F_C4UB_V3F<TR>
<TD>T2F_C3F_V3F <TD>T2F_N3F_V3F<TD>T2F_C4F_N3F_V3F<TD>T4F_C4F_N3F_V4F.<TD>&nbsp;</TABLE>
<P>
<P>Use these rules when specifying <I>format:</I>
<P><TABLE BORDER="1"><TD>If <I>format</I> contains a...<TD>Then...<TR>
<TD>T<TD>Texture coordinates are extracted from the interleaved array.<TR>
<TD>C<TD>Color values are extracted.<TR>
<TD>N<TD>Normal values are extracted.<TR>
<TD>Vertex coordinates are always extracted.<TD>&nbsp;</TABLE>
<P>
<P>The numbers 2, 3, and 4 in the format key specify how many values are extracted. F indicates that values are extracted as floating-point values. Colors may also be extracted as 4 unsigned bytes if 4UB follows the C. If a color is extracted as 4 unsigned bytes, the vertex array element which follows is located at the first possible floating-point aligned address. <P>
<A NAME=HEADING15-60></A>
<H3> <A NAME=MARKER-9-62></A>OpenGL 1.1 and the Vertex Array Extension</H3>
<P>Before OpenGL 1.1 was released, the OpenGL extension EXT_vertex_array provided vertex array functionality in those implementations that supported it. This section briefly lists the differences between the extension and the OpenGL 1.1 functionality:<P>
<UL>
<P><LI>The commands <B>glDrawElements()</B> and <B>glInterleavedArrays()</B> are new in OpenGL 1.1. There was no equivalent functionality in the extension. 
<P><LI>The commands <B>glEnableClientState()</B> and <B>glDisableClientState()</B> are new in OpenGL 1.1. When only the extension was available, individual array elements were enabled and disabled with <B>glEnable()</B> and <B>glDisable()</B>. 
<P><LI>The parameters for the commands <B>glEdgeFlagPointer()</B>, <B>glTexCoordPointer()</B>, <B>glColorPointer()</B>, <B>glIndexPointer()</B>, <B>glNormalPointer()</B>, and<B> glVertexPointer()</B> had a <I>count</I> parameter, which was used to pass information about the number of static elements in an array in the extension. This parameter and the associated functionality does not exist in OpenGL 1.1. See, however, <A HREF=OpenGLonWin-18.html#MARKER-9-13>"The Compiled Vertex Arrays Extension"</A> for a new way of working with static array elements.
</UL>
<P><B>Note:  </B>If an implementation supports both OpenGL 1.1 and the vertex array extension, applications shouldn't to mix calls to extension commands with calls to OpenGL 1.1 commands. If an application does mix calls, the results are unspecified. 
<A NAME=HEADING15-66></A>
<H3> <A NAME=MARKER-9-63></A>New Functions</H3>
<P>glArrayElement(), glDrawArrays(), glVertexPointer(), glNormalPointer(), glColorPointer(), glIndexPointer(), glTexCoordPointer(), glEdgeFlagPointer(), glGetPointerv(), glDrawElements(), glInterleavedArrays(). <A NAME=MARKER-9-64></A><P>

<HR>
<DL>
<DT><A HREF="OpenGLonWin-15.html#HEADING15-11"><B></B>Specifying Vertex Arrays</A><DD>
<DT><A HREF="OpenGLonWin-15.html#HEADING15-29"><B></B>Enabling and Disabling Individual Arrays</A><DD>
<DT><A HREF="OpenGLonWin-15.html#HEADING15-34"><B></B>Transferring Individual Array Elements</A><DD>
<DT><A HREF="OpenGLonWin-15.html#HEADING15-39"><B></B>Combining Array Elements From Different Arrays</A><DD>
<DT><A HREF="OpenGLonWin-15.html#HEADING15-45"><B></B>Rendering Primitives Constructed From a Mesh of Vertices</A><DD>
<DT><A HREF="OpenGLonWin-15.html#HEADING15-51"><B></B>Using Interleaved Arrays</A><DD>
<DT><A HREF="OpenGLonWin-15.html#HEADING15-60"><B></B>OpenGL 1.1 and the Vertex Array Extension</A><DD>
<DT><A HREF="OpenGLonWin-15.html#HEADING15-66"><B></B>New Functions</A><DD>
</DL>

<HR>
<A HREF=OpenGLonWin-16.html>Next</A> | <A HREF=OpenGLonWin-14.html>Prev</A> | <A HREF=OpenGLonWin-12.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
</BODY>
</HTML> 