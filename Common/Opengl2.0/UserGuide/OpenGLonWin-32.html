<!-- Generated by Harlequin Webmaker 2.1.3; Transducer 1.0.2 --> <HTML> <HEAD>
<TITLE>Tuning Animation</TITLE>
</HEAD>
<BODY Y BGCOLOR="efefef" LINK="0000FF" ALINK="FF0000" VLINK="551a8b">
<A NAME=HEADING32></A>
<A HREF=OpenGLonWin-33.html>Next</A> | <A HREF=OpenGLonWin-31.html>Prev</A> | <A HREF=OpenGLonWin-26.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
<HR>
<A NAME=HEADING32-0></A>
<H2> <A NAME=MARKER-9-77></A>Tuning Animation</H2>
<P><A NAME=MARKER-2-78></A>Tuning animation requires attention to some factors not relevant in other types of applications. This section first looks at <A HREF=#MARKER-9-79>Factors Contributing to Animation Speed</A>, then provides some advice for <A HREF=#MARKER-9-87>Optimizing Frame Rate Performance</A>. <P>
<A NAME=HEADING32-2></A>
<H3> <A NAME=MARKER-9-79></A>Factors Contributing to Animation Speed</H3>
<P><A NAME=MARKER-2-80></A>The smoothness of an animation depends on its <A NAME=MARKER-2-81></A>frame rate. The more frames rendered per second, the smoother the motion appears. The basic elements that contribute to the time to render a frame are shown in <A HREF=OpenGLonWin-27.html#MARKER-9-1>Table 4-1</A> above.<A NAME=MARKER-2-82></A><P>
<P>Smooth animation also requires <A NAME=MARKER-2-83></A>double buffering. In double buffering, one framebuffer holds the current frame, which is scanned out to the monitor by video hardware, while the rendering hardware is drawing into a second buffer that is not visible. When the new framebuffer is ready to be displayed, the system swaps the buffers. On hardware implementations, the system must wait until the next vertical retrace period between raster scans to swap the buffers, so that each raster scan displays an entire stable frame, rather than parts of two or more frames. <P>
<P>Frame rates must be integral multiples of the <A NAME=MARKER-2-84></A>screen refresh time, which is 16.7 msec (milliseconds) for a <A NAME=MARKER-2-85></A>60-Hz monitor. If the draw time for a frame is slightly longer than the time for <I>n</I> raster scans, the system waits until the <I>n+1st</I> <A NAME=MARKER-2-86></A>vertical retrace before swapping buffers and allowing drawing to continue, so the total frame time is (<I>n</I>+1)*16.7 msec. <P>
<P>To summarize: On hardware implementations, a change in the time spent rendering a frame has no visible effect unless it changes the total time to a different integer multiple of the screen refresh time. <P>
<P>If you want an observable performance increase, you must reduce the rendering time enough to take a smaller number of 16.7 msec raster scans. Alternatively, if performance is acceptable, you can add work without reducing performance, as long as the rendering time does not exceed the current multiple of the raster scan time.<P>
<P>To help monitor timing improvements, turn off double buffering. If you don't, it's difficult to know if you're near a 16.7 msec boundary. <P>
<A NAME=HEADING32-9></A>
<H3> <A NAME=MARKER-9-87></A>Optimizing Frame Rate Performance</H3>
<P>The most important aid for optimizing frame rate performance on hardware implementations is taking timing measurements in <A NAME=MARKER-2-88></A>single-buffer mode only. (On software implementations, rendering to the front buffer may actually be slower than rendering to the back buffer. Nonetheless, it is important not to include <B>SwapBuffers()</B> in your timing measurement.) For more detailed information, see <A HREF=OpenGLonWin-33.html#MARKER-9-93>"Taking Timing Measurements"</A>.<P>
<P><A NAME=MARKER-2-89></A>In addition, follow these guidelines to optimize frame rate performance:<P>
<UL>
<P><LI>Reduce drawing time to a lower multiple of the screen refresh time. This is the only way to produce an observable performance increase.
<P><LI>Perform non-graphics computation after <B><A NAME=MARKER-2-90></A>SwapBuffers()</B>.
<P>A program is free to do non-graphics computation during the wait cycle between vertical retraces. Therefore, issue a <B>SwapBuffers()</B> call immediately after sending the last graphics call for the current frame, perform computation needed for the next frame, then execute OpenGL calls for the next frame, call <B>SwapBuffers()</B>, and so on.<P>
<P><LI>Do non-drawing work after a screen clear. 
<P>Clearing a full screen takes time. If you make additional <A NAME=MARKER-2-91></A>drawing calls immediately after a screen clear, you may fill up the graphics pipeline and force the program to stall. Instead, do some non-drawing work after the clear. <P>
</UL>
<HR>
<DL>
<DT><A HREF="OpenGLonWin-32.html#HEADING32-2"><B></B>Factors Contributing to Animation Speed</A><DD>
<DT><A HREF="OpenGLonWin-32.html#HEADING32-9"><B></B>Optimizing Frame Rate Performance</A><DD>
</DL>

<HR>
<A HREF=OpenGLonWin-33.html>Next</A> | <A HREF=OpenGLonWin-31.html>Prev</A> | <A HREF=OpenGLonWin-26.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
</BODY>
</HTML> 