<!-- Generated by Harlequin Webmaker 2.1.3; Transducer 1.0.2 --> <HTML> <HEAD>
<TITLE>New Functionality for Working With Textures</TITLE>
</HEAD>
<BODY Y BGCOLOR="efefef" LINK="0000FF" ALINK="FF0000" VLINK="551a8b">
<A NAME=HEADING13></A>
<A HREF=OpenGLonWin-14.html>Next</A> | <A HREF=OpenGLonWin-12.html>Prev</A> | <A HREF=OpenGLonWin-12.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
<HR>
<A NAME=HEADING13-0></A>
<H2> <A NAME=MARKER-9-6></A>New Functionality for Working With Textures</H2>
<P>OpenGL 1.1 provides several new ways of working with textures:<P>
<UL>
<P><LI><A HREF=#MARKER-9-7>"Improving Performance With Predefined Texture Formats"</A>
<P><LI><A HREF=#MARKER-9-9>"New Ways of Using Texture Environments"</A>
<P><LI><A HREF=#MARKER-9-10>"Testing Whether Textures Fit: The Texture Proxy Mechanism"</A>
<P><LI><A HREF=#MARKER-9-15>"Improving Performance With Texture Objects"</A>
<P><LI><A HREF=#MARKER-9-25>"Updating Textures Quickly With Subtextures"</A>
</UL>
<A NAME=HEADING13-7></A>
<H3> <A NAME=MARKER-9-7></A>Improving Performance With Predefined Texture Formats</H3>
<P>When you create a texture using OpenGL 1.0, you can only define it as having 1, 2, 3, or 4 components. OpenGL 1.1 provides several additional predefined formats, which offer these advantages: <P>
<UL>
<P><LI><B>Save space</B>. You can use the formats best suited for the system. Smaller internal formats use less texture memory so more textures can be simultaneously resident in texture memory. This lets you choose optimal storage depending on the display mode: An 8-bit display should use 8-bit texture storage, a 16-bit display should use 16-bit texture storage.
<P><LI><B>Increase speed</B>. OpenGL 1.1 offers a fine-grained selection of sizes. At times, you may prefer using <A NAME=MARKER-2-8></A>16-bit textures to using 32-bit textures because the increase in rendering speed outweighs the slight decrease in image quality. Smaller textures are usually faster and may therefore be preferable if the image quality is sufficient. 
</UL>
<P>To use the new texture formats, call <B>glTexImage1D()</B> or <B>glTexImage2D()</B>, specifying one of the newly-defined tokens as the <I>components</I> parameter. <A HREF=#MARKER-9-2>Table 2-1</A> lists some of the formats defined in OpenGL 1.1; for a complete list, see the reference page for <B>glTexImage*()</B>. <P>
<P><A HREF=#MARKER-9-2>Table 2-1</A> shows the token names with their corresponding base formats and desired component resolutions. It also shows red (R), green (G), blue (B), luminance (L), alpha (A), and intensity (I) values for each format. You can query the actual resolution with <B>glGetTexLevelParameteriv()</B> using the appropriate token, such as GL_TEXTURE_RED_SIZE. All OpenGL implementations accept all tokens, but an implementation doesn't always allocate a resolution exactly equal to that in the table.
<P><TABLE BORDER="1">
<CAPTION><A NAME=MARKER-9-2></A>Some Internal <A NAME=MARKER-2-3></A>Formats Supported in OpenGL 1.1</CAPTION>
<TH>Token Name<TH>Base Format<TH>R<TH>G<TH>B<TH>A<TH>L<TH>I<TR>
<TD>GL_LUMINANCE8<TD>GL_LUMINANCE<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>8<TD>&nbsp;<TR>
<TD>GL_LUMINANCE4_ALPHA4<TD>GL_LUMINANCE_ALPHA <TD>&nbsp;<TD>&nbsp;<TD> <TD>4<TD>4<TD>&nbsp;<TR>
<TD>GL_LUMINANCE12_ALPHA4 <TD>GL_LUMINANCE_ALPHA<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>4<TD>12<TD>&nbsp;<TR>
<TD>GL_LUMINANCE16_ALPHA16 <TD>GL_LUMINANCE_ALPHA<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>16<TD>16<TD>&nbsp;<TR>
<TD>GL_INTENSITY8<TD>GL_INTENSITY<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TD>8<TR>
<TD>GL_RGB4<TD>GL_RGB<TD>4 <TD>4 <TD>4<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TR>
<TD>GL_RGB8<TD>GL_RGB<TD>8<TD>8<TD>8<TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TR>
<TD>GL_RGBA4<TD>GL_RGBA<TD>4<TD>4<TD>4<TD>4<TD>&nbsp;<TD>&nbsp;<TR>
<TD>GL_RGB5_A1<TD>GL_RGBA<TD>5<TD>5<TD>5<TD>1<TD>&nbsp;<TD>&nbsp;<TR>
<TD>GL_RGBA8<TD>GL_RGBA<TD>8<TD>8<TD>8<TD>8<TD>&nbsp;<TD>&nbsp;</TABLE>
<P>
<A NAME=HEADING13-13></A>
<H3> <A NAME=MARKER-9-9></A>New Ways of Using Texture Environments</H3>
<P>The section "Modulating and Blending" in the <I>OpenGL Programming Guide</I> explains how you can use a texture map. You can use it to:<P>
<UL>
<P><LI>Paint a surface.
<P><LI>Modulate the color that the surface would be painted without texturing.
<P><LI>Blend the color in the texture map with the nontextured color of the surface.
</UL>
<P>OpenGL 1.1 expands on that functionality by providing a new texture environment, GL_REPLACE. In addition, you can use two of the new texture formats, GL_ALPHA and GL_INTENSITY, in conjunction with any of the available texture formats. <P>
<P><A HREF=#MARKER-9-1>Table 2-2</A> illustrates how the texture functions use the different texture formats with the different environments (Replace, Modulate, Blend, and Decal). The abbreviations have the following meanings: 
<P><TABLE BORDER="1"><TD>Rv, Gv, Bv, Av<TD>Result of the texture environment function<TR>
<TD>Rt, Gt, Bt, At<TD>Texture color<TR>
<TD>Rf, Gf, Bf, Af<TD>Fragment color<TR>
<TD>Rc, Gc, Bc, Ac<TD>Texture environment color (see GL_TEXTURE_ENV_COLOR)</TABLE>
<P>
<P>
<P><TABLE BORDER="1">
<CAPTION><A NAME=MARKER-9-1></A> Texture Functions</CAPTION>
<TH>Base Texture Format<TH>Replace<TH>Modulate<TH>Blend<TH>Decal<TR>
<TD>GL_<BR>LUMINANCE<TD>Rv = Lt<P>Gv = Lt<P>Bv = Lt<P>Av = Af<TD>Rv = Rf * Lt<P>Gv = Gf * Lt<P>Bv = Bf * Lt<P>Av = Af<TD>Rv = Rf * (1-Lt) + Rc* Lt<P>Gv = Gf * (1-Lt) + Gc * Lt<P>Bv = Bf * (1-Lt) + Bc * Lt<P>Av = Af<TD>undefined<TR>
<TD>GL_ALPHA<TD>Rv = Rf<P>Gv = Gf<P>Bv = Gf<P>Av = At<TD>Rv = Rf<P>Gv = Gf<P>Bv = Gf<P>Av = Af * At<TD>Rv = Rf<P>Gv = Gf<P>Bv = Bf<P>Av = Af * At<TD>undefined<TR>
<TD>GL_<BR>INTENSITY<TD>Rv = It<P>Gv = It<P>Bv = It<P>Av = It<TD>Rv = Rf * It<P>Gv = Gf * It<P>Bv = Bf * It<P>Av = Af * It<TD>Rv = Rf * (1-It) + Rc * It<P>Gv = Gf * (1-It) + Gc * It<P>Bv = Bf * (1-It) + Bc * It<P>Av = Af * (1-It) + AcIt<TD>undefined<TR>
<TD>GL_<BR>LUMINANCE_ALPHA<TD>Rv = Lt<P>Gv = Lt<P>Bv = Lt<P>Av = At<TD>Rv = Rf * Lt<P>Gv = Gf * Lt<P>Bv = Bf * Lt<P>Av = Af * At<TD>Rv = Rf * (1-Lt) + Rc * Lt<P>Gv = Gf * (1-Lt) + Gc * Lt<P>Bv = Bf * (1-Lt) + Bc * Lt<P>Av = Af * At<TD>undefined<TR>
<TD>GL_RGB<TD>Rv = Rt<P>Gv = Gt<P>Bv = Bt<P>Av = Af<TD>Rv = Rf * Rt<P>Gv = Gf * Gt<P>Bv = Bf * Bt<P>Av = Af<TD>Rv = Rf * (1-Rt) + Rc * Rt<P>Gv = Gf * (1-Gt) + Gc * Gt<P>Bv = Bf * (1-Bt) + Bc * Bt<P>Av = Af<TD>Rv = Rt<P>Gv = Gt<P>Bv = Bt<P>Av = Af<TR>
<TD>GL_RBGA<TD>Rv = Rt<P>Gv = Gt<P>Bv = Bt<P>Av = At<TD>Rv = Rf * Rt<P>Gv = Gf * Gt<P>Bv = Bf * Bt<P>Av = Af * At<TD>Rv = Rf * (1-Rt) + Rc * Rt<P>Gv = Gf * (1-Gt) + Gc * Gt<P>Bv = Bf * (1-Bt) + Bc * Bt<P>Av = Af * At<TD>Rv = Rf * (1-At) + Rt * At<P>Gv = Gf * (1-At) + Gt * At<P>Bv = Bf * (1-At) + Bt * At<P>Av = Af</TABLE>
<P>
<A NAME=HEADING13-21></A>
<H3> <A NAME=MARKER-9-10></A>Testing Whether Textures Fit: The Texture Proxy Mechanism</H3>
<P>In OpenGL 1.0, it's difficult to determine whether a texture fits into texture memory on a certain system. When you call <B>glGetIntegerv()</B> with the parameter GL_MAX_TEXTURE_SIZE, you can't be sure of an accurate result: Texel format, component resolution, and the shape of a texture determine whether the texture fits. To ensure that a texture of any format and resolution fits, the function returns a result based on the worst-case scenario. <P>
<P>A solution to this problem is the <A NAME=MARKER-2-11></A>proxy mechanism offered in OpenGL 1.1. To test whether a certain texture fits, follow these steps:<P>
<OL>
<P><LI>Call <B>glTexImage2D()</B> or <B>glTexImage1D()</B> with <I>target</I> set to <A NAME=MARKER-2-12></A>GL_PROXY_TEXTURE_2D or GL_PROXY_TEXTURE_1D (see <A HREF=#MARKER-9-13>Example 2-1</A>).
<P><LI>Test the proxy texture state values to see if the texture would fit and how it would be stored in texture memory by calling <B>glGetTexLevelParameteriv()</B> or <B>glGetTexLevelParameterfv()</B>. Set <I>target</I> to one of the proxy textures: GL_PROXY_TEXTURE_2D or GL_PROXY_TEXTURE_1D. Set <I>pname</I> to the parameter you are interested in, for example, GL_TEXTURE_WIDTH. If the call returns a non-zero value, the texture will fit. 
<P>If the texture is too large, all of the proxy state variables are set to zero. If the texture can be accommodated, these values are set to the requested parameters. The proxy 1D texture behaves like the proxy 2D texture; however, its state does not include GL_TEXTURE_HEIGHT.<P>
<P>You still must call <B>glTexImage2D()</B> with <I>target</I> GL_TEXTURE_2D to define the actual texture.<P>
<P><LI>To determine the maximum array size for a mipmap texture, specify and query the proxy texture at the highest level that accurately reflects the aspect ratio of the desired level zero array.
</OL>
<P><A HREF=#MARKER-9-13>Example 2-1</A> provides a code fragment that determines the largest texture that can be allocated for a given internal image format and aspect ratio. The program incrementally selects larger textures to find the maximum that will fit.<P>
<P>
<B>Example 2-1 </B>: <A NAME=MARKER-9-13></A>Using the <A NAME=MARKER-2-14></A>Proxy Mechanism
<P>
<PRE>
/*
** Demonstrates use of the proxy texture target to probe texture space 
** to determine the largest texture which can be allocated for a given 
** internal image format and aspect ratio. 
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;GL/gl.h&gt;
#include &lt;GL/glu.h&gt;

/* (int)floor(log2(x)) */
static int
intFloorLog2(unsigned int x)
{
    int a = 0;
    while (x &gt;&gt;= 1) ++a;
    return a;
}

/* true if x is a power of two */
static GLboolean
isPow2(unsigned int x)
{
    return ((x &gt; 0) &amp;&amp; (x &amp; (x - 1) == 0));
}

/* find largest texture with specified internal format and aspect */
static void
findMaxTexture(GLenum internalFormat, int dim,
    int xAspect, int yAspect, int border, int maxMipmapLevel,
    int *widthOut, int *heightOut)
{
    int level = 0, levelOffset = 0;
    int width = 1, height = 1;
    int maxLevel = 0, maxWidth = 0, maxHeight = 0;

    if (xAspect &gt; yAspect) {
        width = xAspect / yAspect;
        levelOffset = intFloorLog2(width);
    } else {
        height = yAspect / xAspect;
        levelOffset = intFloorLog2(height);
    }

    while (1) {
        GLint proxyComponents;

        switch (dim) {
          case 1:
            glTexImage1D(GL_PROXY_TEXTURE_1D,
                         level, internalFormat,
                         width+2*border, border,
                         GL_RGBA, GL_UNSIGNED_BYTE, NULL);
            
            glGetTexLevelParameteriv(GL_PROXY_TEXTURE_1D, level,
                    GL_TEXTURE_COMPONENTS, &amp;proxyComponents);
            break;
          case 2:
            glTexImage2D(GL_PROXY_TEXTURE_2D,
                     level, internalFormat,
                     width+2*border, height+2*border, border,
                     GL_RGBA, GL_UNSIGNED_BYTE, NULL);
               
            glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D,level
                     GL_TEXTURE_COMPONENTS,&amp;proxyComponents);
            break;
          default:
            *widthout = 0; 
            *heightout = 0;
            return;
        }
        
        if (proxyComponents != internalFormat) {
           /* proxy allocation failed -- we're done */
            break;
        } else {
           /* proxy allocation succeeded -- see how we did */
               if (level&gt;maxLevel || width&gt;maxWidth || 
                                                    height&gt;maxHeight)
            {
                maxLevel = level;
                maxWidth = width &lt;&lt; level;
                maxHeight = height &lt;&lt; level;
            }
        }

        if (maxMipmapLevel == 0) {
       /* try the next larger image size at level zero */
            width &lt;&lt;= 1;
            height &lt;&lt;= 1;
        } else {
       /* try same image size at next higher mipmap level */
            ++level;
            if (level+levelOffset &gt; maxMipmapLevel) {
       /* can't query levels which don't exist--we're done */
                break;
            }
        }
    }

    if (maxWidth&gt;0 &amp;&amp; maxHeight&gt;0) {
        maxWidth += 2*border;
        maxHeight += 2*border;
    }
    *widthOut = maxWidth;
    *heightOut = maxHeight;
}
static void
displayTextureSizeInfo(void)
{
    GLint maxTextureSize, maxTextureLevel;
    int maxWidth, maxHeight;

    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;maxTextureSize);
    printf(&quot;GL_MAX_TEXTURE_SIZE: %d\n&quot;, maxTextureSize);

    maxTextureLevel = intFloorLog2(maxTextureSize);

    findMaxTexture(GL_RGB, 2, 1, 1, 0, 0, &amp;maxWidth, &amp;maxHeight);
    printf(&quot;RGB 1:1 (%d x %d)\n&quot;, maxWidth, maxHeight);

    findMaxTexture(GL_RGBA, 2, 2, 1, 0, 0, &amp;maxWidth, &amp;maxHeight);
    printf(&quot;RGBA 2:1 (%d x %d)\n&quot;, maxWidth, maxHeight);

    findMaxTexture(GL_RGB, 2, 1, 1, 0, maxTextureLevel, &amp;maxWidth, 
                                                        &amp;maxHeight);
    printf(&quot;RGB 1:1 (%d x %d) mipmap\n&quot;, maxWidth, maxHeight);

    findMaxTexture(GL_LUMINANCE_ALPHA, 2, 1, 1, 1, 0, &amp;maxWidth, 
                                                      &amp;maxHeight);
    printf(&quot;LUMINANCE_ALPHA 1:1 (%d x %d) w/border\n&quot;, maxWidth,
                                                       maxHeight);
}
</PRE>
<A NAME=HEADING13-165></A>
<H3> <A NAME=MARKER-9-15></A>Improving Performance With Texture Objects</H3>
<P>Texture objects can improve the performance of programs that use multiple textures. You can create as many textures as you need and switch from one texture to another efficiently. A new texture parameter, the priority, can be used to tell the system which textures should have priority when it allocates hardware resources.<P>
<P>This section first provides some background information in <A HREF=#MARKER-9-16>How Texture Objects Work</A>. You then learn about <A HREF=#MARKER-9-17>Using Texture Objects</A> in general terms, and about two special topics, <A HREF=#MARKER-9-18>Texture Object Names</A> and <A HREF=#MARKER-9-20>Editing and Querying Texture Objects</A>. <A HREF=#MARKER-9-21>Texture Priorities and Residency</A> explains how you can indicate which textures should have preference when hardware resources are allocated. Finally, <A HREF=#MARKER-9-24>Default Textures</A> explains how you can access OpenGL 1.0 textures. <P>
<A NAME=HEADING13-168></A>
<H4> <A NAME=MARKER-9-16></A>How Texture Objects Work</H4>
<P>In OpenGL 1.0, only one texture can be associated with each of the texture targets GL_TEXTURE_1D and GL_TEXTURE_2D. If you want to render a scene that contains many 2D textures, you have to redefine the 2D texture, calling <B>glTexImage2D()</B> for each texture in the scene. If you want each texture to have different parameters, such as wrap modes and filters, you have to redefine those as well.<P>
<P>In OpenGL 1.1, you can create as many textures as you need. You associate a name (a positive number) with a texture object when you create it, and you define the images and parameters of the texture. As you render your scene, you bind the name of each desired texture object to the appropriate texture target. Since binding a texture takes less time than defining one, this is an efficient way to switch from one texture to another. <P>
<P><B>Note:  </B>Texture objects and display lists are in different name spaces. However, if two contexts are sharing display lists, they also share texture objects.
<A NAME=HEADING13-172></A>
<H4> <A NAME=MARKER-9-17></A>Using Texture Objects</H4>
<P>To create a texture object, bind an unused name to a texture target. The name is considered to be in use until you delete the texture. The following code fragment creates, defines, and binds texture objects with the names 1 and 2:<P>
<P>
<B>Example 2-2 </B>: Using Texture Objects
<P>
<PRE>
/* the first bind of 1 will create the texture object */
glBindTexture( GL_TEXTURE_2D, 1 );
/* define the texture image and parameterss */
glTexImage2D( GL_TEXTURE_2D, 0, 4, 32, 32, 0, GL_RGBA, GL_BYTE, img1 );
glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP );

/* the first bind of 2 will create the texture object */
glBindTexture( GL_TEXTURE_2D, 2 );
/* define the texture image and parameters */
glTexImage2D( GL_TEXTURE_2D, 0, 4, 64, 64, 0, GL_RGBA, GL_BYTE, img2 );
glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );

/* bind each texture object as scene is rendered */
glBindTexture( GL_TEXTURE_2D, 1 );
&lt;draw some primitive&gt;
glBindTexture( GL_TEXTURE_2D, 2 );
&lt;draw some primitive&gt;
</PRE>
<P>There is also an example program in the source tree that demonstrates how to use texture objects. <P>
<A NAME=HEADING13-193></A>
<H4> <A NAME=MARKER-9-18></A>Texture Object Names</H4>
<P>You can create a texture object with any name that isn't already the name of another texture object. To find out whether a particular name is in use, call <B>glIsTexture()</B>. As a convenience,<A NAME=MARKER-2-19></A> <B>glGenTextures()</B> returns a set of texture names that are known to be unused.<P>
<P>To delete one or more texture objects, call <B>glDeleteTextures()</B>. After a texture object is deleted, its name is freed; it has no contents, and its resources are returned to the system.<P>
<A NAME=HEADING13-196></A>
<H4> <A NAME=MARKER-9-20></A>Editing and Querying Texture Objects</H4>
<P>Once a texture object has been created, you can change its images and parameters at any time. You edit a texture object the same way you define it: bind the texture object to a target and then call <B>glTexImage*()</B> or <B>glTexParameter*()</B>. These commands take a texture target as an argument, and they affect the texture object that is currently bound to that target. Similarly, you can query the parameters and images of a texture by calling <B>glGetTexParameter*()</B>, <B>glGetTexLevelParameter*()</B>, and <B>glGetTexImage()</B>, which also operate on the currently bound texture.<P>
<P>To find out which texture object is currently bound to each texture target, call <B>glGetIntegerv()</B> with GL_TEXTURE_BINDING_1D or GL_TEXTURE_BINDING_2D.<P>
<A NAME=HEADING13-199></A>
<H4> <A NAME=MARKER-9-21></A>Texture Priorities and Residency</H4>
<P>On some systems, textures must reside in hardware resources such as texture memory before they can be used. When you bind a texture, the system may need to swap out some other textures to make room, if the application's textures do not all fit in texture memory.<P>
<P>An application can guide the system in determining which textures should remain resident by specifying a priority for each texture using <B><A NAME=MARKER-2-22></A>glPrioritizeTextures()</B>. Each priority value is clamped to the range 0 to 1, with 0 indicating the lowest priority (and the least likelihood of being resident), and 1 indicating the highest priority. You can also set the priority of a single texture by calling <B>glTexParameter*()</B> with GL_TEXTURE_PRIORITY. Note that the performance effects, if any, of setting texture priorities are entirely system dependent.<P>
<P>You can query whether a set of texture objects is resident by calling <B><A NAME=MARKER-2-23></A>glAreTexturesResident()</B>, and you can query whether a single texture object is resident by calling <B>glGetTexParameter*()</B> with GL_TEXTURE_RESIDENT.<P>
<A NAME=HEADING13-203></A>
<H4> <A NAME=MARKER-9-24></A>Default Textures</H4>
<P>You can still access the OpenGL 1.0 textures, now called the "default textures," by binding 0 to a texture target. This is in fact the initial binding when you create a rendering context. When you create a texture object, its images and parameters are the same as the initial settings of the default textures.<P>
<P>You can set the priority of a default texture by calling <B>glTexParameter*()</B>; you cannot use <B>glPrioritizeTextures()</B> with a default texture. Similarly, you can query the residence of a default texture with <B>glGetTexParameter*()</B>, but you cannot do so with <B>glAreTexturesResident()</B>. <P>
<A NAME=HEADING13-206></A>
<H3> <A NAME=MARKER-9-25></A>Updating Textures Quickly With Subtextures</H3>
<P>OpenGL 1.1 lets you replace a subrectangle of an existing texture image without affecting the remaining portions of the image. Using a subtexture is the fastest way to update only the image of a texture.<A NAME=MARKER-2-26></A> When you intend to redefine only the image of the texture and keep all other parameters, using subtexture is much faster than a <B>glTexImage*()</B> call. <P>
<P>Subtextures are especially useful under these circumstances:<P>
<UL>
<P><LI>When you're dealing with an image that doesn't fit into texture memory, you can load only parts of the texture and replace them as appropriate.
<P><LI>When you're working with an image that has a width and height that's not a power of 2, you can't directly use it as a texture. This can be a problem, fore example, when you're using <A NAME=MARKER-2-27></A>video frames as textures: none of the common video formats (NTSC, PAL, SECAM, HD-TV, and so on) have a height and width of those dimensions. You can solve this problem by creating a NULL texture whose dimensions are larger than the video frame and then load the video frame as a subtexture. 
<P><LI>When you're working with an animation, loading a large texture may decrease the frame rate. Instead, load several subtextures over multiple frames to maintain a high frame rate.
</UL>
<P>In this section, you learn about <A HREF=#MARKER-9-28>Using Subtextures</A> and <A HREF=#MARKER-9-30>Using Null Images With Subtextures</A>. <A HREF=#MARKER-9-33>New and Extended Functions</A> provides information about new functions and functions that changed in OpenGL 1.1 to provide subtexture functionality.<P>
<A NAME=HEADING13-213></A>
<H4> <A NAME=MARKER-9-28></A>Using Subtextures</H4>
<P>To load a subrectangle of a texture image, call <B>glTexSubImage1D()</B>, <B>glTexSubImage2D() </B>(prototype below) or <B>glTexSubImage3D()</B>. <P>
<PRE>
void <A NAME=MARKER-2-29></A>glTexSubImage2D (enum <I>target</I>, int <I>level</I>, int <I>xoffset</I>,int <I>yoffset</I>, 
</PRE>
<P><CODE>sizei <I>width</I>, sizei <I>height</I>, enum <I>format</I>, enum <I>type</I>, const void* <I>pixels</I>)</CODE>
<UL>
<P><LI><I>target</I> specifies the existing texture image for which the subimage is being defined.
<P><LI><I>level</I>, <I>depth</I>, <I>format</I>, <I>type</I>, and <I>pixels</I> correspond to the arguments of <B>glTexImage2D()</B>.
<P><LI><I>width</I> and <I>height</I> are those of the subimage.
<P><LI><I>xoffset</I> and <I>yoffset</I> specify texel offsets in the x and y directions within the texture image being modified.
</UL>
<P>Using any uninitialized portion of a texture while drawing yields undefined results.<P>
<A NAME=HEADING13-222></A>
<H4> <A NAME=MARKER-9-30></A>Using Null Images With Subtextures</H4>
<P><A NAME=MARKER-2-31></A>It is sometimes useful to define the parameters of a texture image without actually initializing the contents of that image. For example, if you want to load a frame of an NTSC video as a texture, you need to first define a region larger than the video frame that meets the height and width requirements of textures (power of 2). Null images are also useful when you want to first define the parameters of a texture and later initialize the texture image using <B>glTexSubImage*()</B> calls.<P>
<P>To create a null image, call one of the texture creation functions, for example, <B>glTexImage2D()</B> with <I>pixels </I>set to the null pointer. The specified texture is created, but no pixels are processed. Using an uninitialized part of a texture yields undefined results.<P>
<P>The following code fragment creates a null image texture, then loads a subimage: <P>
<PRE>
{
/* need to initialize "image" to something interesting */
    static unsigned char image[32][32][4]; 
/* create a 256 x 256 null texture */
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB5, 256, 256, 0,
                 GL_RGBA, GL_UNSIGNED_BYTE, NULL);
/* load a 32 x 32 subimage starting at 100,110 */
    glTexSubImage2D(GL_TEXTURE_2D, 0, 100, 110, 32, 32,
                       GL_RGBA, GL_UNSIGNED_BYTE, image);
} 
</PRE>
<A NAME=HEADING13-236></A>
<H3> Loading Textures From the Framebuffer</H3>
<P>In OpenGL 1.0, image data for a texture comes from host memory. In OpenGL 1.1, you can load texture images directly from the framebuffer. You can replace either part of the texture image or the whole image.<P>
<P>Using this functionality, you can do multi-pass rendering, using the full set of OpenGL rendering capabilities to generate a texture you can use for further drawing. For example, you can render a scene, copy the resulting image to texture memory, and then apply the texture to a triangle mesh. By changing the mesh, you can warp the scene, break it into pieces, wrap it around complex objects, and so on. <P>
<A NAME=HEADING13-239></A>
<H4> Copying Texture Images</H4>
<P>The functions <B><A NAME=MARKER-2-32></A>glCopyTexImage1D()</B> and <B>glCopyTexImage2D()</B> copy image data from the color buffer specified by the current read buffer rather than accepting image data from host memory. <P>
<P>To copy an image from the framebuffer, call <B>glCopyTexImage2D()</B>, <B>glCopyTexImage1D()</B>, <B>glCopyTexSubImage1D()</B>, or <B>glCopyTexSubImage2D()</B>. The prototypes for the four functions are very similar; the prototype of <B>glCopyTexImage2D()</B> is provided below as an example: <P>
<PRE>
void glCopyTexImage2D ( GLenum <I>target</I>,GLint <I>level</I>,GLenum <I>internalformat</I>,
           GLint <I>x</I>, GLint <I>y</I>, GLsizei <I>width</I>, GLsizei <I>height</I>, GLint <I>border</I>)
</PRE>
<UL>
<P><LI><I>target</I> and <I>level</I> are equivalent to their <B>glTexImage2D()</B> counterparts, except that <I>target</I> does not accept GL_PROXY_TEXTURE_2D.
<P><LI><I>internalformat</I> is identical to the <I>components</I> parameter of <B>glTexImage2D()</B>, except that <B>glCopyTexImage2D()</B> does not accept the values 1, 2, 3, and 4 but instead the internal formats defined in OpenGL 1.1, some of which are listed in <A HREF=#MARKER-9-2>Table 2-1</A>. For complete information, see the reference page for glCopyTexImage2D().
<P><LI>Each function reads image data from a color buffer region that is (<I>width+2*border_pixel)</I> wide and<I> (height+2*border_pixel</I>) high, and whose lower-left pixel has window coordinates <I>x</I>,<I>y</I>. 
</UL>
<P>The pixel values are processed exactly as if <B>glCopyPixels()</B> had been called, but the process stops just before final conversion, that is, before clamping and conversion to fragments. At this point all pixel component values are clamped to [0,1], and then treated exactly as if the corresponding <B>glTexImage*()</B> or <B>glTexSubImage*() </B>had been called. Pixel ordering is such that lower x screen coordinates correspond to lower i (horizontal) texture coordinates, and lower y screen coordinates correspond to lower j (vertical) texture coordinates. <P>
<A NAME=HEADING13-248></A>
<H3> <A NAME=MARKER-9-33></A>New and Extended Functions</H3>
<P>For additional information about new texture functionality, see the reference pages for the following functions, which are either new in OpenGL1.1 or have been modified significantly because of additions and changes:<P>
<P><B>New</B>: glGenTextures(), glDeleteTextures(), glIsTexture(), glBindTexture() glPrioritizeTextures(), glAreTexturesResident(), glTexSubImage1D(), glTexSubImage2D(), glTexSubImage2D().glCopyTexImage1D(), glCopyTexImage2D(), glCopyTexSubImage1D(), glCopyTexSubImage2D(), glCopyTexSubImage3D().<P>
<P><B>Extended</B>: glTexImage1D(), glTexImage2D(), glGetTexLevelParameteriv(), glTexEnvf(), glTexEnvi(), glTexEnvfv(), glTexEnviv(), glGetTexLevelParameterfv(), glGetParameterTex*().<P>
<HR>
<DL>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-7"><B></B>Improving Performance With Predefined Texture Formats</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-13"><B></B>New Ways of Using Texture Environments</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-21"><B></B>Testing Whether Textures Fit: The Texture Proxy Mechanism</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-165"><B></B>Improving Performance With Texture Objects</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-168"><B></B>How Texture Objects Work</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-172"><B></B>Using Texture Objects</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-193"><B></B>Texture Object Names</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-196"><B></B>Editing and Querying Texture Objects</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-199"><B></B>Texture Priorities and Residency</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-203"><B></B>Default Textures</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-206"><B></B>Updating Textures Quickly With Subtextures</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-213"><B></B>Using Subtextures</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-222"><B></B>Using Null Images With Subtextures</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-236"><B></B>Loading Textures From the Framebuffer</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-239"><B></B>Copying Texture Images</A><DD>
<DT><A HREF="OpenGLonWin-13.html#HEADING13-248"><B></B>New and Extended Functions</A><DD>
</DL>

<HR>
<A HREF=OpenGLonWin-14.html>Next</A> | <A HREF=OpenGLonWin-12.html>Prev</A> | <A HREF=OpenGLonWin-12.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
</BODY>
</HTML> 