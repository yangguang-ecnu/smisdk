<!-- Generated by Harlequin Webmaker 2.1.3; Transducer 1.0.2 --> <HTML> <HEAD>
<TITLE>Tuning the Geometry Subsystem</TITLE>
</HEAD>
<BODY Y BGCOLOR="efefef" LINK="0000FF" ALINK="FF0000" VLINK="551a8b">
<A NAME=HEADING28></A>
<A HREF=OpenGLonWin-29.html>Next</A> | <A HREF=OpenGLonWin-27.html>Prev</A> | <A HREF=OpenGLonWin-26.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
<HR>
<A NAME=HEADING28-0></A>
<H2> <A NAME=MARKER-9-23></A>Tuning the Geometry Subsystem<A NAME=MARKER-2-24></A></H2>
<P>A number of optimizations are possible for the geometry subsystem:<P>
<UL>
<P><LI><A HREF=#MARKER-9-25>"Using Peak-Performance Primitives"</A>
<P><LI><A HREF=#MARKER-9-29>"Using Vertex Arrays"</A>
<P><LI><A HREF=#MARKER-9-30>"Using Drawing Modes Appropriately"</A>
<P><LI><A HREF=#MARKER-9-38>"Optimizing Lighting Performance"</A>
<P><LI><A HREF=#MARKER-9-48>"Advanced Geometry-Limited Tuning Techniques"</A>
</UL>
<A NAME=HEADING28-7></A>
<H3> <A NAME=MARKER-9-25></A>Using Peak-Performance Primitives</H3>
<P>This section describes how to draw geometry with optimal primitives. Consider these guidelines to optimize drawing:<P>
<UL>
<P><LI>Use connected primitives (line strips, <A NAME=MARKER-2-26></A>triangle strips, triangle fans, and quad strips).
<P>Connected primitives are desirable because they reduce the amount of data and the amount of per-polygon or per-edge work done by OpenGL.<P>
<P><LI>Use "well-behaved" polygons--convex and planar, with only three or four vertices. 
<P><A NAME=MARKER-2-27></A>Concave and self-intersecting polygons must be tessellated by GLU before they can be drawn, and are therefore prohibitively expensive. Nonplanar polygons and polygons with large numbers of vertices are more likely to exhibit shading artifacts.<P>
<P>If your database has polygons that are not well-behaved, perform an initial one-time pass over the database to change the troublemakers into well-behaved polygons and use the new database for rendering. You can store the results in OpenGL display lists. Using connected primitives results in additional gains.<P>
<P><LI>Minimize the data sent per vertex.
<P>Polygon rates can be affected directly by the number of normals or colors sent per polygon. Setting a color or normal per vertex, regardless of the <B>glShadeModel()</B> used, may be slower than setting only a color per polygon, because of the time spent sending the extra data and resetting the current color. The number of normals and colors per polygon also directly affects the size of a display list containing the object.<P>
<P><LI>If your model has backfacing surfaces that can be culled using the normals, send a normal/vertex, even if you do not have lighting enabled (see <A HREF=OpenGLonWin-19.html#MARKER-9-24>"The Object Space Vertex Culling Extension"</A>).
<P><LI>Group like primitives and minimize state changes to reduce pipeline revalidation.<A NAME=MARKER-2-28></A>
<P><LI>Use normalized normals. 
<P><LI>Avoid non-uniform scaling operations.
</UL>
<A NAME=HEADING28-20></A>
<H3> <A NAME=MARKER-9-29></A>Using Vertex Arrays </H3>
<P>Vertex arrays are available in OpenGL 1.1 (see <A HREF=OpenGLonWin-15.html#MARKER-9-48>"OpenGL 1.1 Vertex Arrays"</A>). They offer the following benefits: <P>
<UL>
<P><LI>The OpenGL implementation can take advantage of uniform data formats. 
<P><LI>The <B>glInterleavedArrays()</B> call lets you specify packed vertex data easily. Packed vertex formats are typically faster for OpenGL to process.
<P><LI>The <B>glDrawArrays()</B> call reduces subroutine call overhead.
<P><LI>The <B>glDrawElements()</B> call reduces subroutine call overhead and also reduces per-vertex calculations because vertices are reused. The lock/unlock call can further reduce per-vertex calculations. 
</UL>
<P>One possible disadvantage to vertex arrays over using <B>glBegin()</B>/<B>glEnd()</B> is that it may require additional memory usage.<P>
<P>If you use <B>glBegin()</B>/<B>glEnd()</B> instead of <B>glDrawArrays()</B> or <B>glDrawElements()</B> calls, put as many vertices as possible between the <B>glBegin()</B> and the <B>glEnd()</B>. This amortizes the cost of the call and also makes it easier to batch vertices.<P>
<P>Note that in situations where vertices are shared, it makes sense to lock them down for optimum performance. See <A HREF=OpenGLonWin-18.html#MARKER-9-13>"The Compiled Vertex Arrays Extension."</A><P>
<A NAME=HEADING28-29></A>
<H3> <A NAME=MARKER-9-30></A>Using Drawing Modes Appropriately</H3>
<P>This section discusses ways of reducing per-vertex costs.<A HREF=#MARKER-9-31></A><P>
<A NAME=HEADING28-31></A>
<H4> <A NAME=MARKER-9-31></A>Using Fast Drawing Modes</H4>
<P>For optimum performance, use <A NAME=MARKER-2-32></A>flat shading whenever possible. This reduces the number of lighting computations from one per vertex to one per primitive, and also reduces the amount of data that must be processed for each primitive. This is particularly important for high-performance line drawing.<P>
<A NAME=HEADING28-33></A>
<H4> <A NAME=MARKER-9-33></A>Using Expensive Modes<A NAME=MARKER-2-34></A> Efficiently</H4>
<P>OpenGL offers many features that create sophisticated effects with excellent performance. However, these features have some performance cost, compared to drawing the same scene without them. Use these features only where their effects, performance, and quality are justified.<P>
<UL>
<P><LI>Turn off features when they are not required.
<P>Once a feature has been turned on, it can slow the transform rate even when it has no visible effect.<P>
<P>For example, the use of <A NAME=MARKER-2-35></A>fog can slow the transform rate of polygons even when the polygons are too close to show fog, and even when the fog density is set to zero. For these conditions, turn off fog explicitly with<P>
<P><CODE>glDisable(GL_FOG) </CODE>
<P><LI>Minimize expensive mode changes. Sort operations by the most expensive mode. Specifically, consider these tips:
<UL>
<P><LI>Use small numbers of texture maps to avoid the cost of switching between <A NAME=MARKER-2-36></A>textures. If you have many small textures, consider combining them into a single larger, tiled texture. Rather than switching to a new texture before drawing a textured polygon, choose texture coordinates that select the appropriate small texture tile within the large texture.
<P><LI>Avoid changing the projection matrix or changing <B><A NAME=MARKER-2-37></A>glDepthRange()</B> parameters.
<P><LI>When fog is enabled, avoid changing fog parameters.
<P><LI>Turn fog off for rendering with a different projection (for example, orthographic) and turn it back on when returning to the normal projection.
</UL>
<P><LI>Beware of excessive mode changes, even mode changes considered cheap, such as changes to shade model, depth buffering, and blending functions.
<P><LI>When you do need to change state, consider using <B>glPushAttrib()/glPopAttrib()</B>; it is sometimes faster.
</UL>
<A NAME=HEADING28-46></A>
<H3> <A NAME=MARKER-9-38></A>Optimizing Lighting Performance<A NAME=MARKER-2-39></A></H3>
<P>OpenGL offers a large selection of lighting features: The penalties some features carry may vary depending on the hardware you're running on. Be prepared to experiment with the lighting configuration.<P>
<P>As a general rule, use the simplest possible lighting model, a single infinite light with an infinite viewer. For some local effects, try replacing local lights with infinite lights and a local viewer.<P>
<P>Use the following settings for peak performance <A NAME=MARKER-2-40></A>lighting:<P>
<UL>
<P><LI>single infinite light
<P><LI><A NAME=MARKER-2-41></A>nonlocal viewing--GL_LIGHT_MODEL_LOCAL_VIEWER set to GL_FALSE in <B>glLightModel()</B> (the default)
<P><LI><A NAME=MARKER-2-42></A>single-sided lighting--GL_LIGHT_MODEL_TWO_SIDE set to GL_FALSE in <B>glLightModel()</B> (the default)
<P><LI>GL_COLOR_MATERIAL or GL_INDEX_MATERIAL_SGI disabled
<P><LI>GL_NORMALIZE disabled--because this is usually necessary when the model-view matrix includes a scaling transformation, consider preprocessing the scene to eliminate scaling.
</UL>
<P>In addition, follow these guidelines to achieve peak lighting performance:<P>
<UL>
<P><LI>Avoid using local lights.
<P>Local lights are noticeably more expensive than infinite lights.<P>
<P><LI>Don't change<A NAME=MARKER-2-43></A> material parameters frequently.
<P>Changing material parameters can be expensive. If you need to change the material parameters many times per frame, consider rearranging the scene traversal to minimize material changes. Also consider using <B><A NAME=MARKER-2-44></A>glColorMaterial()</B> or <B>glIndexMaterialSGI() </B>to change specific parameters automatically, rather than using <B>glMaterial()</B> to change parameters explicitly.<P>
<P>The following code fragment illustrates how to change ambient and diffuse material parameters at every polygon or at every vertex:<P>
<P><CODE>glColorMaterial(GL_FRONT_AND_BACK,GL_AMBIENT_AND_DIFFUSE);</CODE>
<P><CODE>glEnable(GL_COLOR_MATERIAL);</CODE>
<P><CODE>...</CODE>
<P><CODE>/* Set ambient and diffuse material parameters: */</CODE>
<P><CODE>glColor4f(red, green, blue, alpha);</CODE>
<P><CODE>/* Draw triangles: */</CODE>
<P><CODE>glBegin(GL_TRIANGLES);</CODE>
<P><CODE>...</CODE>
<P><CODE>glEnd();</CODE>
<P><LI>Local viewing: Setting GL_LIGHT_MODEL_LOCAL_VIEWER to GL_TRUE with <B>glLightModel()</B>, while using infinite lights only, reduces performance by a small amount. However, each additional <A NAME=MARKER-2-45></A>local light noticeably degrades the transform rate.
<P><LI>Two-sided lighting illuminates both sides of a polygon. This is much faster than the alternative of drawing polygons twice. However, using <A NAME=MARKER-2-46></A>two-sided lighting is significantly slower than one-sided lighting for a single rendering of an object.
<P><LI>Use unit-length normals.
<P><LI>Avoid scaling operations if possible. 
<P><LI>Avoid changing the <A NAME=MARKER-2-47></A>GL_SHININESS material parameter if possible. Setting a new GL_SHININESS value requires significant computation each time.
<P><LI>Avoid using lighting calls inside a <B>glBegin()/glEnd()</B> sequence.
<P><LI>If possible, avoid calls to <B>glMaterial()</B> during a <B>glBegin()/glEnd()</B> drawing sequence, as this has a serious performance impact. While making such calls to change colors by changing material properties is possible, the performance penalty makes it unadvisable. Use <B>glColorMaterial()</B> or <B>glIndexMaterialSGI()</B> instead.
</UL>
<A NAME=HEADING28-77></A>
<H3> <A NAME=MARKER-9-48></A>Advanced Geometry-Limited Tuning Techniques</H3>
<P>This section describes advanced techniques for tuning transform-limited drawing. Follow these guidelines to draw objects with complex surface characteristics:<P>
<UL>
<P><LI>Use <B><A NAME=MARKER-2-49></A>glAlphaFunc()</B> in conjunction with one or more textures to give the effect of rather complex geometry on a single polygon.
<P>Consider drawing an image of a complex object by texturing it onto a single polygon. Set alpha values to zero in the texture outside the image of the object. (The edges of the object can be antialiased by using <A NAME=MARKER-2-50></A>alpha values between zero and one.) Orient the polygon to face the viewer. To prevent pixels with zero alpha values in the textured polygon from being drawn, call<P>
<P><CODE>glAlphaFunc(GL_NOTEQUAL, 0.0)</CODE>
<P>This effect is often used to create objects like trees that have complex edges or many holes through which the background should be visible (or both), such as trees. <P>
<P><LI>Eliminate objects or polygons that will be out of sight or too small to see<A NAME=MARKER-2-51></A>.<A NAME=MARKER-2-52></A>
<P><LI>Use fog to increase visual detail without drawing small background objects. 
</UL>
<HR>
<DL>
<DT><A HREF="OpenGLonWin-28.html#HEADING28-7"><B></B>Using Peak-Performance Primitives</A><DD>
<DT><A HREF="OpenGLonWin-28.html#HEADING28-20"><B></B>Using Vertex Arrays </A><DD>
<DT><A HREF="OpenGLonWin-28.html#HEADING28-29"><B></B>Using Drawing Modes Appropriately</A><DD>
<DT><A HREF="OpenGLonWin-28.html#HEADING28-31"><B></B>Using Fast Drawing Modes</A><DD>
<DT><A HREF="OpenGLonWin-28.html#HEADING28-33"><B></B>Using Expensive Modes Efficiently</A><DD>
<DT><A HREF="OpenGLonWin-28.html#HEADING28-46"><B></B>Optimizing Lighting Performance</A><DD>
<DT><A HREF="OpenGLonWin-28.html#HEADING28-77"><B></B>Advanced Geometry-Limited Tuning Techniques</A><DD>
</DL>

<HR>
<A HREF=OpenGLonWin-29.html>Next</A> | <A HREF=OpenGLonWin-27.html>Prev</A> | <A HREF=OpenGLonWin-26.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
</BODY>
</HTML> 