<!-- Generated by Harlequin Webmaker 2.1.3; Transducer 1.0.2 --> <HTML> <HEAD>
<TITLE>Introduction to OpenGL on Windows</TITLE>
</HEAD>
<BODY Y BGCOLOR="efefef" LINK="0000FF" ALINK="FF0000" VLINK="551a8b">
<A NAME=HEADING10></A>
<A HREF=OpenGLonWin-11.html>Next</A> | <A HREF=OpenGLonWin-9.html>Prev</A> | <A HREF=OpenGLonWin-9.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
<HR>
<A NAME=HEADING10-0></A>
<H2> <A NAME=MARKER-9-2></A>Introduction to OpenGL on Windows</H2>
<P>The technical articles <I>OpenGL I: QuickStart</I> and <I>Introducing the OpenGL Interface</I> (both available online from Microsoft) explain in some detail how an OpenGL program fits inside a Windows environment. (See <A HREF=OpenGLonWin-7.html#MARKER-9-5>"Background Reading"</A> for bibliographical information.) This chapter provides only minimal introductory information. <A HREF=#MARKER-9-4>Figure 1-1</A> illustrates the relation between OpenGL and GDI, the Windows graphics interface. The rest of the section first provides an <A HREF=#MARKER-9-3>Architectural Overview of Windows and OpenGL</A>, then briefly defines <A HREF=#MARKER-9-5>OpenGL and Windows Terminology</A> used in the rest of this document. <P>
<A NAME=HEADING10-2></A>
<H3> <A NAME=MARKER-9-3></A>Architectural Overview of Windows and OpenGL</H3>
<P>As you can see in <A HREF=#MARKER-9-4>Figure 1-1</A>, OpenGL uses the display driver, which directly interacts with the display hardware. Your Windows application uses OpenGL just as it would use GDI or another applications programmer interface (API). <P>
<P> <IMG SRC="OGLandWin-1.gif"><P>
<P>
<B>Figure 1-1 </B>: <A NAME=MARKER-9-4></A>How OpenGL Fits Into the Windows Environment
<P>
<A NAME=HEADING10-6></A>
<H3> <A NAME=MARKER-9-5></A>OpenGL and Windows Terminology</H3>
<P><B>GDI and Device Contexts</B>--GDI is the original Windows 2D graphics interface. GDI is capable of drawing to the screen, to memory, to printers, and so on. GDI makes this possible using a Device Context (DC). All GDI calls pass through a DC and the DC knows how to render to that device. <P>
<P><B>Rendering Contexts</B>--A rendering context (RC) is bound to a DC. An RC in an OpenGL program plays the same role that a DC plays in a GDI program. For GDI, the DC is, in part, a repository of state variables--for example, the current color of the current pen. A rendering context is such a depository for OpenGL. <P>
<P><B>Pixel Formats</B>--Pixel formats determine the configuration of the color and ancillary buffers associated with a DC or RC. They are the translation layer between OpenGL calls and the actual rendering operation that Windows performs. There are four Windows OpenGL functions that handle the pixel format: <B>ChoosePixelFormat()</B>, <B>SetPixelFormat()</B>, <B>GetPixelFormat()</B>, and<B> DescribePixelFormat(). </B><P>
<HR>
<DL>
<DT><A HREF="OpenGLonWin-10.html#HEADING10-2"><B></B>Architectural Overview of Windows and OpenGL</A><DD>
<DT><A HREF="OpenGLonWin-10.html#HEADING10-6"><B></B>OpenGL and Windows Terminology</A><DD>
</DL>

<HR>
<A HREF=OpenGLonWin-11.html>Next</A> | <A HREF=OpenGLonWin-9.html>Prev</A> | <A HREF=OpenGLonWin-9.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
</BODY>
</HTML> 