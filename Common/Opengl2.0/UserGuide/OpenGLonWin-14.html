<!-- Generated by Harlequin Webmaker 2.1.3; Transducer 1.0.2 --> <HTML> <HEAD>
<TITLE>Polygon Offset Functionality</TITLE>
</HEAD>
<BODY Y BGCOLOR="efefef" LINK="0000FF" ALINK="FF0000" VLINK="551a8b">
<A NAME=HEADING14></A>
<A HREF=OpenGLonWin-15.html>Next</A> | <A HREF=OpenGLonWin-13.html>Prev</A> | <A HREF=OpenGLonWin-12.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
<HR>
<A NAME=HEADING14-0></A>
<H2> <A NAME=MARKER-9-34></A>Polygon Offset Functionality</H2>
<P>OpenGL 1.1 polygon offset functionality is useful for rendering <A NAME=MARKER-2-35></A>hidden-line images, rendering solids with <A NAME=MARKER-2-36></A>highlighted edges, and applying <A NAME=MARKER-2-37></A>decals to surfaces. This can result in a sharper image, for example, when you want to render outlines on surfaces. The <A NAME=MARKER-2-38></A>lines are not rasterized the same way the polygons are. This results in slightly different depth values which, when used by the depth buffering mechanism, cause some of the line pixels to show and some not to show. This is because triangles and lines produce different depth values and the system cannot tell ahead of time what will be in front. <P>
<P>This section discusses <A HREF=#MARKER-9-39>Using Polygon Offset Functionality</A>, followed by a <A HREF=#MARKER-9-42>Polygon Offset Example Program</A> and <A HREF=#MARKER-9-46>New Functions</A>.<P>
<A NAME=HEADING14-3></A>
<H3> <A NAME=MARKER-9-39></A>Using Polygon Offset Functionality</H3>
<P>To use polygon offset functionality, you have to first call <B>glEnable()</B> with argument GL_POLYGON_OFFSET. You can then use the <B>glPolygonOffset()</B> function to offset polygon pixels in the depth buffer so that lines and points no longer interact, and that clean polygon outlines are rendered as a result.<A NAME=MARKER-2-40></A> You can later disable this functionality by calling <B>glDisable()</B> with argument GL_POLYGON_OFFSET.<P>
<P>Using the <B>glPolygonOffset()</B> function, you can displace the <A NAME=MARKER-2-41></A>depth values of fragments generated by rendering polygons by a fixed bias plus an amount. The amount is proportional to the maximum absolute value of the depth slope of the polygon, measured and applied in window coordinates. This displacement<P>
<UL>
<P><LI>allows lines (or points) and polygons in the same plane to be rendered without interaction: the lines are rendered either completely in front of or behind the polygons (depending on the sign of the offset factor)
<P><LI>allows multiple coplanar polygons to be rendered without interaction, if different offset factors are used for each polygon 
</UL>
<A NAME=HEADING14-8></A>
<H3> <A NAME=MARKER-9-42></A>Polygon Offset Example Program</H3>
<P>This section illustrates how to use the <B>glPolygonOffset()</B> function by providing code fragments from an example program <I>hiddenline.c</I> that displays three images:<P>
<UL>
<P><LI>The left image shows an ordinary wireframe image. 
<P><LI>The center image shows a hidden-line image without polygon offset.
<P><LI>The right image shows a hidden-line image using polygon offset to reduce artifacts. 
</UL>
<P><A HREF=#MARKER-9-45>Figure 2-1</A> shows the output that the program generates. You are encouraged to run the program yourself to see the difference clearly.<P>
<P>
<B>Example 2-3 </B>: <A NAME=MARKER-2-43></A><A NAME=MARKER-9-44></A>Polygon Offset Example Program
<P>
<PRE>
/**********************************************************************
 * Uses PolygonOffset to draw hidden-line images. PolygonOffset 
 * shifts z values of polygons by an amount proportional to their slope
 * in screen z. This keeps the lines, which are drawn without 
 * displacement, from interacting with their respective polygons, and 
 * and thus eliminates line dropouts.
 */

#include &lt;GL/gl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAXQUAD 6

typedef float Vertex[3];

typedef Vertex Quad[4];

Quad quads[MAXQUAD] = {    /*data to define six faces of a unit cube */
    0,0,0, 1,0,0, 1,1,0, 0,1,0,
    0,0,1, 1,0,1, 1,1,1, 0,1,1,
    0,0,0, 1,0,0, 1,0,1, 0,0,1,
    0,1,0, 1,1,0, 1,1,1, 0,1,1,
    0,0,0, 0,0,1, 0,1,1, 0,1,0,
    1,0,0, 1,0,1, 1,1,1, 1,1,0
};
#define WIREFRAME       0
#define HIDDEN_LINE     1

/*** function prototypes go here  ***/
static int dimension = 3;

static void init (void)
{
    /*** window system setup goes here ***/

    /* set up viewing parameters */
    glMatrixMode(GL_PROJECTION);
    gluPerspective(20, 1, 0.1, 20);
    glMatrixMode(GL_MODELVIEW);
    glTranslatef(0, 0, -15);

    /* set other relevant state information */
    glEnable(GL_DEPTH_TEST);
    glPolygonOffset(1.0, 2);

    /* event processing goes here */
   
}

static void
draw_scene(int mx, int my) {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix();
    glTranslatef(-1.7, 0.0, 0.0);
    cubes(mx, my, WIREFRAME);
    glPopMatrix();

    glPushMatrix();
    cubes(mx, my, HIDDEN_LINE);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(1.7, 0.0, 0.0);
    glEnable(GL_POLYGON_OFFSET_FILL);
    cubes(mx, my, HIDDEN_LINE);
    glDisable(GL_POLYGON_OFFSET_FILL);
    glPopMatrix();
}

static void
cubes(int mx, int my, int mode) {
    int x, y, z, i;

    /* track the mouse */
    glRotatef(mx / 2.0, 0, 1, 0);
    glRotatef(my / 2.0, 1, 0, 0);

    /* draw the lines as hidden polygons */
    glTranslatef(-0.5, -0.5, -0.5);
    glScalef(1.0/dimension, 1.0/dimension, 1.0/dimension);
    for (z = 0; z &lt; dimension; z++) {
        for (y = 0; y &lt; dimension; y++) {
            for (x = 0; x &lt; dimension; x++) {
                glPushMatrix();
                glTranslatef(x, y, z);
                glScalef(0.8, 0.8, 0.8);
                for (i = 0; i &lt; MAXQUAD; i++)
                    draw_hidden(quads[i], mode);
                glPopMatrix();
            }
        }
    }
}

static void
fill(Quad quad) {
    glBegin(GL_QUADS);
    glVertex3fv(quad[0]);
    glVertex3fv(quad[1]);
    glVertex3fv(quad[2]);
    glVertex3fv(quad[3]);
    glEnd();
}


static void
outline(Quad quad) {
    /* draw an outlined polygon */
    glBegin(GL_LINE_LOOP);
    glVertex3fv(quad[0]);
    glVertex3fv(quad[1]);
    glVertex3fv(quad[2]);
    glVertex3fv(quad[3]);
    glEnd();
}

static void
draw_hidden(Quad quad, int mode) {
    /* draw outline using white, optionally fill interior with black */
    glColor3f(1, 1, 1);
    outline(quad);

    if (mode == HIDDEN_LINE) {
        glColor3f(0, 0, 0);
        fill(quad);
    }
}

/* Put input processing code here if desired */

    draw_scene(deltax, deltay);
}
</PRE>
<P> <IMG SRC="hiddenline.gif"><P>
<P>
<B>Figure 2-1 </B>: <A NAME=MARKER-9-45></A>Polygon Offset Extension Example
<P>
<A NAME=HEADING14-152></A>
<H3> <A NAME=MARKER-9-46></A>New Functions</H3>
<P><A NAME=MARKER-2-47></A>glPolygonOffset().<P>
<HR>
<DL>
<DT><A HREF="OpenGLonWin-14.html#HEADING14-3"><B></B>Using Polygon Offset Functionality</A><DD>
<DT><A HREF="OpenGLonWin-14.html#HEADING14-8"><B></B>Polygon Offset Example Program</A><DD>
<DT><A HREF="OpenGLonWin-14.html#HEADING14-152"><B></B>New Functions</A><DD>
</DL>

<HR>
<A HREF=OpenGLonWin-15.html>Next</A> | <A HREF=OpenGLonWin-13.html>Prev</A> | <A HREF=OpenGLonWin-12.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
</BODY>
</HTML> 