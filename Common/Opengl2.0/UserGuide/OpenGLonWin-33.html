<!-- Generated by Harlequin Webmaker 2.1.3; Transducer 1.0.2 --> <HTML> <HEAD>
<TITLE>Taking Timing Measurements</TITLE>
</HEAD>
<BODY Y BGCOLOR="efefef" LINK="0000FF" ALINK="FF0000" VLINK="551a8b">
<A NAME=HEADING33></A>
<A HREF=OpenGLonWin-34.html>Next</A> | <A HREF=OpenGLonWin-32.html>Prev</A> | <A HREF=OpenGLonWin-26.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
<HR>
<A NAME=HEADING33-0></A>
<H2> <A NAME=MARKER-9-92></A><A NAME=MARKER-9-93></A>Taking Timing Measurements</H2>
<P>Timing, or <A NAME=MARKER-2-94></A>benchmarking, parts of your program is an important part of tuning. It helps you determine which changes to your code have a noticeable effect on the speed of your application. <P>
<P><A NAME=MARKER-9-95></A>To achieve performance that is demonstrably close to the best the hardware can achieve, you can first follow the more general tuning tips provided here, but you then need to apply a rigorous and systematic analysis, as discussed in these section:<P>
<UL>
<P><LI><A HREF=#MARKER-9-96>"Benchmarking Basics"</A>
<P><LI><A HREF=#MARKER-9-104>"Achieving Accurate Timing Measurements"</A>
<P><LI><A HREF=#MARKER-9-112>"Achieving Accurate Benchmarking Results"</A>
</UL>
<A NAME=HEADING33-6></A>
<H3> <A NAME=MARKER-9-96></A>Benchmarking Basics</H3>
<P><A NAME=MARKER-2-97></A>A detailed analysis involves examining what your program is asking the system to do and then calculating how long that should take, based on the known performance characteristics of the hardware. Compare this <A NAME=MARKER-2-98></A>calculation of expected performance with the performance actually observed and continue to apply the tuning techniques until the two match more closely. At this point, you have a detailed accounting of how your program spends its time, and you are in a strong position both to tune further and to make appropriate decisions considering the speed-versus-quality trade-off.<P>
<P>The following parameters determine the <A NAME=MARKER-2-99></A>performance of most applications:<P>
<UL>
<P><LI>total number of <A NAME=MARKER-2-100></A>polygons in a frame
<P><LI><A NAME=MARKER-2-101></A>transform rate for the given polygon type and mode settings
<P><LI>number of pixels filled
<P><LI>fill rate for the given <A NAME=MARKER-2-102></A>mode settings
<P><LI>time of color and depth buffer clear<A NAME=MARKER-2-103></A>
<P><LI>time of buffer swap
<P><LI>time of application overhead
<P><LI>number of attribute changes and time per change
</UL>
<A NAME=HEADING33-17></A>
<H3> <A NAME=MARKER-9-104></A>Achieving Accurate Timing Measurements</H3>
<P>Consider these guidelines to get accurate <A NAME=MARKER-2-105></A>timing measurements:<P>
<UL>
<P><LI>Take measurements on a quiet system.
<P>Verify that no unusual activity is taking place on your system while you take timing measurements. Close other Windows applications; for example, don't have a clock or a network application running while you are <A NAME=MARKER-2-106></A>benchmarking.<P>
<P><LI>Choose timing trials that are not limited by the <A NAME=MARKER-2-107></A>clock resolution.
<P>Use a high-resolution clock and make measurements over a period of time that's at least one hundred times the clock resolution. A good rule of thumb is to benchmark something that takes at least two seconds so that the uncertainty contributed by the clock reading is less than one percent of the total error. To measure something that's faster, write a loop to execute the test code repeatedly.<P>
<P><B>Note:  </B>Loops like this for timing measurements are highly recommended. Be sure to structure your program in a way that facilitates this approach. <A NAME=MARKER-2-108></A>
<P>Use <B>QueryPerformanceCounter()</B> or <B>QueryPerformanceFrequency()</B> to measure time.<P>
<P><LI>Benchmark <A NAME=MARKER-2-109></A>static frames.
<P>Verify that the code you are timing behaves identically for each frame of a given timing trial. If the scene changes, the current bottleneck in the graphics pipeline may change, making your timing measurements meaningless. For example, if you are benchmarking the drawing of a rotating airplane, choose a single frame and draw it repeatedly, instead of letting the airplane rotate and taking the benchmark. Once a single frame has been analyzed and tuned, look at frames that stress the graphics pipeline in different ways, then analyze and tune them individually.<P>
<P><LI>Compare multiple trials.
<P>Run your program multiple times and try to understand variance in the trials. Variance may be due to other programs running, system activity, prior memory placement, or other factors. <P>
<P><LI>Call <A NAME=MARKER-2-110></A><B>glFinish()</B> before reading the clock at the start and at the end of the time trial.
<P>This is important if you are using a machine with hardware acceleration because the graphics commands are put into a hardware queue in the graphics subsystem, to be processed as soon as the graphics pipeline is ready. The CPU can immediately do other work, including issuing more graphics commands until the queue fills up.<P>
<P>When <A NAME=MARKER-2-111></A>benchmarking a piece of graphics code, you must include in your measurements the time it takes to process all the work left in the queue after the last graphics call. Call <B>glFinish()</B> at the end of your timing trial, just before sampling the clock. Also call <B>glFinish()</B> before sampling the clock and starting the trial, to ensure no graphics calls remain in the graphics queue ahead of the process you are timing.<P>
</UL>
<A NAME=HEADING33-32></A>
<H3> <A NAME=MARKER-9-112></A>Achieving Accurate Benchmarking Results</H3>
<P>To benchmark performance for a particular code fragment, follow these steps:<P>
<OL>
<P><LI>Determine how many polygons are being drawn and estimate how many pixels they cover on the screen. Have your program count the polygons when you read in the database.
<P>To determine the number of pixels filled, start by making a visual estimate. Be sure to include surfaces that are hidden behind other surfaces, and notice whether or not backface elimination is enabled. For greater accuracy, use feedback mode and calculate the actual number of pixels filled.<P>
<P><LI>Determine the transform and fill rates on the target system for the mode settings you are using.
<P>Refer to the product literature for the target system to determine some transform and fill rates. Determine others by writing and running small benchmarks.<P>
<P><LI>Divide the number of polygons drawn by the transform rate to get the time spent on per-polygon operations.
<P><LI>Divide the number of pixels filled by the fill rate to get the time spent on per-pixel operations.
<P><LI>Measure the time spent in the application.
<P>To determine time spent executing instructions in the application, perform the graphics-stubbing experiment described in <A HREF=OpenGLonWin-27.html#MARKER-9-17>"Finding Bottlenecks in Your Application"</A>.<P>
</OL>
<P>This process takes some effort to complete. In practice, it's best to make a quick start by making some assumptions, then refine your understanding as you tune and experiment. Ultimately, you need to experiment with different rendering techniques and perform repeated benchmarks, especially when the unexpected happens.<A NAME=MARKER-10-113></A> <P>
<P>Verify some of the suggestions presented in the following chapter. Try some techniques on a small program that you understand and use benchmarks<A NAME=MARKER-10-114></A> to observe the effects. <A HREF=#MARKER-9-116>Figure 4-1</A> shows how you may actually go through the process of benchmarking and reducing bottlenecks several times.<A NAME=MARKER-2-115></A><P>
<P> <IMG SRC="tune.gif"><P>
<P>
<B>Figure 4-1 </B>: <A NAME=MARKER-9-116></A>Flowchart of the Tuning Process
<P>
<HR>
<DL>
<DT><A HREF="OpenGLonWin-33.html#HEADING33-6"><B></B>Benchmarking Basics</A><DD>
<DT><A HREF="OpenGLonWin-33.html#HEADING33-17"><B></B>Achieving Accurate Timing Measurements</A><DD>
<DT><A HREF="OpenGLonWin-33.html#HEADING33-32"><B></B>Achieving Accurate Benchmarking Results</A><DD>
</DL>

<HR>
<A HREF=OpenGLonWin-34.html>Next</A> | <A HREF=OpenGLonWin-32.html>Prev</A> | <A HREF=OpenGLonWin-26.html>Up</A> | <A HREF=OpenGLonWin-1.html>Top</A> | <A HREF=OpenGLonWin-3.html>Contents</A> | <A HREF=OpenGLonWin-36.html>Index</A><BR>
</BODY>
</HTML> 